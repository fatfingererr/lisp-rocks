<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <meta charset="utf-8" />
    <title>(print &quot;Lisp Rocks&quot;): 〈微軟測試之道〉閱讀筆記</title>
    <link rel="canonical" href="http://lisp.rocks/posts-output/2018-02-13-〈微軟測試之道〉閱讀筆記/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Vollkorn' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/github.min.css">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"> 
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
    <script>
    window.klipse_settings = {
        selector: '.language-klipse' // css selector for the html elements you want to klipsify
    };
    </script>
    <script src="/js/highlight.pack.js" type="text/javascript"></script>
    <script>
    hljs.initHighlightingOnLoad();
    </script>
</head>

<body>
    <nav class="navbar navbar-default">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-title" href="/">(print &quot;Lisp Rocks&quot;)</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse" style="position: absolute; right: 0;">
            <ul class="nav navbar-nav">
                <li ><a href="/">Home</a></li>
                <li ><a href="/archives/">Archives</a></li>
                
                <li >
                    <a href="/pages-output/about/">About</a>
                </li>
                
            </ul>
        </div>
        <!--/.nav-collapse -->
        <!--/.container-fluid -->
    </nav>
    <div>
        <div>
            <div>
                <div id="content">
                    
<div id="post">
    <div class="post-header">
    <div id="post-meta" class="row">
        
    </div>
    <h2>〈微軟測試之道〉閱讀筆記</h2>
        <div id="post-date">
            February 13, 2018
        </div>
</div>
<div>
    
    <h1><a name=""></a></h1><h2><a name=""></a></h2><h2><a name="測試工程師常見的任務"></a>測試工程師常見的任務</h2><ul><li>開發測試工具</li><li>開發針對安全或性能測試的工具</li><li>API 或協議測試的自動化</li><li>BUG 大掃除 ( bug bashes )</li><li>撰寫測試計畫</li><li>寫測試案例的文件</li><li>執行手工測試</li><li>核心測試範例自動化</li></ul><p>從這裡面我可以切出 8 張票</p><pre><code>- &#91; &#93; 1, 撰寫 scripts 自動測試
    - &#91; &#93; 1.1. 單元測試
    - &#91; &#93; 1.2. 效能測試
    - &#91; &#93; 1.3. 安全測試
- &#91; &#93; 2. API 測試自動化
- &#91; &#93; 3. 安排時間 Bug bashes &#40;大家一起找 bug&#41;
- &#91; &#93; 撰寫測試計畫
    - &#91; &#93; 添加到規格書中
- &#91; &#93; 寫測試案例的文件
    - &#91; &#93; 針對核心測試範例寫文件</code></pre><h2><a name="里程碑模式"></a>里程碑模式</h2><p>對項目的版本做規劃，每個里程碑都要有：</p><ul><li>階段標準 Exit Criteria<ul><li>關鍵功能完畢</li><li>中期測試目標達到 ( 代碼覆蓋率 + 測試完成率達標 )</li><li>缺陷目標達到 ( 無 P1 Bug , 第一嚴重 BUg )</li><li>非功能目標達到 ( 性能, 負荷測試完成, 無嚴重問題 )</li></ul></li></ul><p>各里程碑(M1,M2,M3,Release) 的目標</p><ul><li>M0<ul><li>準備各種定義<ul><li>目標文件</li><li>專案管理流程</li><li>發布目標</li><li>功能規格書</li><li>功能優先次序表</li><li>里程碑進度</li></ul></li></ul></li><li>M1<ul><li>執行：無要求</li><li>覆蓋：都能測量並生成報告</li><li>可靠性：無要求</li><li>功能：無要求</li><li>性能：完成性能測試並生成報告</li></ul></li><li>M2<ul><li>執行：P1 Case 都能執行</li><li>覆蓋：65%</li><li>可靠性：解決 M1 中 50% Issue</li><li>功能：20% 擁有公開介面</li><li>性能：確立性能基準線與目標性能</li></ul></li><li>M3<ul><li>執行：P1 Case + P2 Case 都能執行</li><li>覆蓋：75%</li><li>可靠性：解決 M2 中 50% Issue</li><li>功能：50% 擁有公開介面</li><li>性能：全面性能測試自動化完成</li></ul></li><li>Private Build:<ul><li>一個介在 M3 與 Release 之間的版本</li></ul></li><li>Release:<ul><li>所有 Case 都能執行</li><li>覆蓋：80%</li><li>解決 M3 中 70% Issue</li><li>功能：100% 公開介面</li><li>性能：全面性能目標達到</li></ul></li><li>MQ:<ul><li>Release 之後到下個階段之前，空檔時間能還債</li><li>大量 debug</li><li>規劃一個 Code Review 流程</li><li>衡量所有 bug 哪些 bug 可以在更早之前里程碑解決掉, 並找到衡量方法<ul><li>例如 for 迴圈 20 行</li></ul></li></ul></li></ul><h2><a name="質量門檻"></a>質量門檻</h2><ul><li>L1 所有測試都通過</li><li>L2 功能性 Bug 都修復, Issue 都關閉</li><li>L3 性能要求達標</li><li>L4 測試計畫書完成，對所有測試都有提供說明</li><li>L5 所有程式碼都通過審查</li><li>L6 文件完成</li><li>L7 安全性的應對計畫已完成</li><li>L8 代碼覆蓋率達 80%</li><li>L9 所有功能在不同環境中都能正常運作</li></ul><h2><a name="宏觀視野"></a>宏觀視野</h2><ul><li>開發人員的輸出粒度：<ul><li>程式碼 Code</li><li>函數 functionality</li><li>產品功能 feature<ul><li>戰術：怎麼工作的更有效率</li></ul></li><li>專案 Project<ul><li>戰略&戰術</li></ul></li><li>產品線 Product<ul><li>長期戰略</li><li>業務需求</li></ul></li></ul></li></ul><h2><a name="各階段版本"></a>各階段版本</h2><ul><li>LKG (Last Know Good) 已知最近一個符合特定質量標準的版本<ul><li>L1 LKG, L2 LKG, L3 LKG, L4 LKG &#x2026;</li></ul></li><li>Self-host 自用版 - 內部團隊可以在日常生活中使用的版本</li><li>Visual freeze 介面凍結版本<ul><li>在某個時間點開始視覺效果和 API 介面被凍結, 在發行前不再改變</li></ul></li><li>debug build 除錯版 裡面支援很多除錯功能的版本</li><li>free build 銷售版 為發行而做各種最後優化得到的版本</li><li>Alpha 目標是得到功能和可用性的初步回饋的版本</li><li>Beta 預定發布的版本，希望得到反饋</li></ul><h2><a name="測試規格"></a>測試規格</h2><ul><li>目標與摘要</li><li>策略</li><li>功能測試</li><li>元件測試</li><li>整合測試</li><li>互操作性測試</li><li>一致性測試</li><li>國際化測試/全球化測試</li><li>性能測試</li><li>安全測試</li><li>安全或部屬測試</li><li>依賴關係釐清</li><li>各種度量方法</li></ul><h2><a name="測試用例"></a>測試用例</h2><ul><li>驗證測試</li><li>錯誤避免測試</li><li>開心路徑</li></ul><h2><a name="功能測試"></a>功能測試</h2><ul><li>等價類劃分 Equivalence class partitioning ECP<ul><li>如何對等價類劃分為合法和非法子集? 變數分解<ul><li>過量分解會造成 false negatives / false positives</li><li>總是避免冗餘測試</li><li>四種啟發式方法<ul><li>範圍</li><li>分組</li><li>唯一值</li><li>特殊值</li></ul></li><li>子集分類以 v 開頭 ex: v1, v2, v3, v4</li><li>建立 "測試設計矩陣"</li><li>ECP 目的主要是暴露 "單點故障"<ul><li>單點故障假設 : 通常系統很少是 2 或多個故障共同作用的結果</li></ul></li></ul></li></ul></li><li>邊界值分析 BVA<ul><li>邊界值的測試數量可以用 4n+1 來計算, n = 獨立參數個數</li><li>建立 BVA 測試矩陣</li><li>隱性邊界<ul><li>不是所有邊界都能透過數字輸入輸出確定</li><li>例如視窗高低, 循環指令的邊界</li></ul></li><li>the deja-vu heuristic 定義最小邊界值和忽上忽下於邊界值的數值<ul><li>循環指令的邊界以內, 不准進入錯誤處理分支</li><li>循環指令的邊界上和外，必須初始化錯誤處理分支</li></ul></li></ul></li><li>組合分析<ul><li>對於半耦合 (semicouple) 的參數的測試方法<ul><li>分支測試 EC<ul><li>對每個變數都測試至少一次</li></ul></li><li>基準測試 BC<ul><li>指定一組變數作為基準來測試</li><li>通常是快樂路徑常用的變量狀態組合</li></ul></li><li>正交陳列 OA</li><li>組合測試 t=n<ul><li>可以隨機化生成這些矩陣, 方便提高廣度</li><li>矩陣中的配對, 可以盡可能找到合適的覆蓋率</li><li>以及可以接受的未覆蓋函數量</li></ul></li><li>窮舉測試 AC</li></ul></li></ul></li><li>標準覆蓋率<ul><li>這個階段主要依賴腳本化測試</li></ul></li><li>實際可達覆蓋率<ul><li>這個階段透過探索性測試</li><li>並再依定情況開始採用結構測試</li></ul></li></ul><h2><a name="結構測試"></a>結構測試</h2><ul><li>塊狀測試 Block Test<ul><li>針對程式碼中的一個個 Block 做測試</li><li>另一個重要性是在異常處理 Exception Handling</li></ul></li><li>決策測試 Decision Testing<ul><li>主要對 if/else 來測試</li><li>不能有效評估複合條件判斷流程</li></ul></li><li>條件測試 Condition Testing<ul><li>多個條件語句 AND/OR 組合而成</li><li>劃出控制流程圖</li><li>在寫出函數中各個條件的 true/false 的測試矩陣以及期待值</li></ul></li><li>基礎路徑測試 Basic Path Testing<ul><li>對整個控制流程進行測試</li><li>圈複雜度 cyclomatic complexity</li><li>基礎路徑技術 baseline path technique</li><li>簡化基礎路徑技術 simplified baseline path technique</li><li>實用基礎路徑技術 practical baseline path technique</li></ul></li></ul><h2><a name="程式碼複雜度"></a>程式碼複雜度</h2><ul><li>LOC 程式碼行數</li><li>圈複雜度 cyclomatic complexity<ul><li>1-10 低風險</li><li>11-20 中等複雜度</li><li>21-50 高度複雜度</li><li>50+ 非常高風險/不可測試</li><li>圈複雜度高不代表缺陷就多<ul><li>煙霧警告度量：煙多不保證火災</li></ul></li></ul></li><li>Halstead 測量<ul><li>主要用於衡量可維護姓</li></ul></li><li>對物件的測量<ul><li>類權重方法 WMC 類中的方法數</li><li>繼承樹深度 DIT 一個類繼承的類總數</li><li>物件間耦合度 CBO 一個類引用其他類的總數</li><li>扇入扇出 fan-in/fan-out 衡量一個類有調用到其他類多少次<ul><li>如果一個類方法被調用 5 次而這 5 次會造成他調用其他 10 個類</li><li>那扇入就是 5 而扇出就是 10</li></ul></li></ul></li></ul><h2><a name="基於模型的測試"></a>基於模型的測試</h2><ul><li>MBT Model-based testing</li><li>基於模型的刺是不是為了 end-to-end scenario</li><li>而是為了中間的過程變化</li><li>smart monkey test 聰明猴子測試, 隨機行走<ul><li>在整個模型流程中隨機執行跳轉各步驟</li></ul></li></ul><h2><a name="bug&#95;處理流程"></a>Bug 處理流程</h2><ul><li>運行測試 -> 建立 bug 報告 -> 三方會審 triage</li><li>重現 Reproduction<ul><li>How Found: 怎麼重現錯誤</li><li>Issue Type: 程式碼問題, 設計問題, 文件問題</li><li>Bug Type: 安全, 性能, 功能 &#x2026;</li><li>Source: 測試來源</li></ul></li><li>缺陷沒有被批准就不修正<ul><li>重複的 bug (duplicate)</li><li>推遲 Postpone</li><li>外部錯誤 External</li><li>設計錯誤 By Design</li></ul></li><li>批准了就要開始調查 inverstigation approved 看是什麼問題<ul><li>必須修正 Must Fix</li><li>應修正 Should Fix</li><li>有時間就修正 Fix if time</li></ul></li><li>提出如何修正</li></ul><h2><a name="缺陷的衡量&#95;metric"></a>缺陷的衡量 Metric</h2><ul><li>修復的缺陷/所有解決的缺陷相對其他 Issue 的比例<ul><li>用這個來衡量開發處於早期還是晚期</li></ul></li><li>各種程式語言/平台的缺陷比例<ul><li>衡量環境問題和開發的是否有特定領域瓶頸</li></ul></li><li>缺陷發現率<ul><li>太高或太低都要擔心, 對峰值進行解釋</li></ul></li><li>錯誤修正率<ul><li>當標準提高後, 修正比例應該下降</li></ul></li><li>根據不同領域來看缺陷數<ul><li>可能那個領域需要更多測試或協助</li></ul></li><li>不同嚴重性的缺陷數<ul><li>隨著發展嚴重性S1,S2 應該要像降, 而S3,S4會上升 Severity</li><li>一般期待在早期發現更多嚴重的缺陷</li></ul></li><li>缺陷重新復發比率<ul><li>這是一個衡量程序修正質量很好的標準</li><li>當專案快要結束時, 這個會開始變多和達到最大</li></ul></li><li>平均反映缺陷時間<ul><li>跟蹤開發團隊對缺陷的反應速度</li></ul></li><li>平均關閉缺陷時間<ul><li>反映大家對問題的解決速度</li></ul></li><li>缺陷門檻 (缺陷 bars)<ul><li>指一個開發人員在一定時間內所能接受的缺陷數量</li><li>當超過這個數量介會被停止開發功能, 必須立即修補缺陷</li><li>但也可能被濫用, 大家分工缺陷量</li></ul></li></ul><h2><a name="測試用例模板"></a>測試用例模板</h2><ul><li>測試用例編號</li><li>功能區</li><li>功能分區</li><li>優先級 (1,2,3,4)</li><li>類別 (功能性?性能?負載?)</li><li>頻率 (每次構建?)<ul><li>版本驗證測試 BVT</li><li>每夜測試</li><li>里程碑測試</li><li>內部迭代至少一次</li></ul></li><li>測試時間</li><li>運行方式<ul><li>手動/半自動化(需要一定程度手動)/自動化</li></ul></li><li>描述<ul><li>測試目的<ul><li>到底要驗證什麼</li></ul></li><li>初始條件和背景<ul><li>確定那些條件是重要的先決條件</li></ul></li><li>步驟(測試點 Test Point)        1.</li></ul></li></ul><pre><code>    2.</code></pre><pre><code>    3.
-   預期結果
    -   通過 Pass
    -   受一個具體的檢查點 checkpoint 規範
-   備註</code></pre><h2><a name="自動化測試"></a>自動化測試</h2><ul><li>設置 Setup<ul><li>將環境設定好</li></ul></li><li>執行 Execution<ul><li>執行測試的特定步驟,充分錯誤處理,其他相關工作</li></ul></li><li>分析 Analysis<ul><li>分析為什麼失敗</li></ul></li><li>報告 Reporting<ul><li>報告包含日誌/資料庫/其他分析結果文件</li></ul></li><li>清理 Cleanup<ul><li>清理當前環境狀態已讓下次繼續進行</li></ul></li><li>幫助 Help<ul><li>在其測試生命週期如何保持可維護性</li></ul></li><li>測試日誌應該包含的元素<ul><li>測試ID Test ID</li><li>測試名稱 Test Name</li><li>環境訊息 Environment Information</li><li>被測程式訊息 Application Under Test Information AUT Info</li><li>測試結果 Test Result</li></ul></li><li>測試結果的分類<ul><li>通過 Pass</li><li>失敗 Fail</li><li>跳過 SKip 跳過環境不支援的特定測試</li><li>放棄 Abort 測試失效時就直接放棄</li><li>阻斷 Block 被阻止不會讓測試失敗率更加增高</li><li>警告 Warn 雖然通過了旦指出需要更細緻檢查某些地方</li></ul></li></ul><h2><a name="其他工具"></a>其他工具</h2><ul><li>churn 改動: 在一段時間內, 文件和模塊被修改的次數<ul><li>也就是被改動的次數<ul><li>修改次數</li><li>增加行數</li><li>刪除行數</li><li>修改行數</li></ul></li></ul></li><li>Total churn 可以顯示出在哪個地方可能有最多潛在 bug</li><li>驗收測試 BATs Build acceptance tests/ BVTs Build verification tests</li><li>應該每天或更頻繁的 Build<ul><li>rolling builds 滾動構建</li><li>自動同步到最新的 code</li></ul></li><li>BATs 比 BVT 範圍小一點</li><li>BVT 屬性<ul><li>Automate Everything (在每次 Build 前運行)</li><li>Test a little (驗證基本功能的簡單測試, 確保構建可被用於測試)</li><li>Test Fast (要求快速幾分鐘測試, 快速給予反饋)</li><li>Fail Perfectly 如果 BVT 失敗要立即修復失敗的地方</li><li>Test Broadly not Deeply 盡可能多涵蓋關鍵功能</li><li>Debuggable and Maintainable (BVT 會自動到 code 裡面找哪個change造成)</li><li>Trustworthy 可信 (要能信任 BVT 通過)</li><li>Critical 關鍵 (BVT 應該由最值得信賴的人建立)</li></ul></li><li>程式碼分析成本 Code Analysis Overload<ul><li>全新項目早期分析的缺陷幾乎注意不到</li><li>成熟階段使用帶來額外工作量</li></ul></li></ul><h2><a name="後記"></a>後記</h2><p>花一個晚上看完，覺得收穫良多，裡面還有推薦很多參考書籍，未來可以看看</p><h2><a name="buzz&#95;word"></a>Buzz Word</h2><ul><li>TTM ( Time to market ) 產品從構思到銷售的總時間</li><li>assign 指派修正</li><li>postpone 推辭處理 -> 技術負債</li><li>不要聽河馬的<ul><li>河馬 HiPPO ( Highest Paid Person's Opinion ) 指最高薪資的人</li></ul></li><li>BDUF - Big Design Up Front 指各種費時的預先設計和撰寫文件的動作</li><li>look and feel 外再體驗</li></ul>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags-output/reading/">reading</a>
    
    <a href="/tags-output/testing/">testing</a>
    
</div>


    <div id="prev-next">
        
        <a href="/posts-output/2018-11-07-在-Emacs-中使用-counsel-gtags/">&laquo; 在 Emacs 中使用 counsel-gtags</a>
        
        
        <a class="right" href="/posts-output/2018-02-13-Emacs-中透過-which-function-mode-取得當前游標所在的函數名稱/">Emacs 中透過 (which-function) 取得當前函數名稱 &raquo;</a>
        
    </div>

    
    <div id="disqus_thread"></div>

    <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = "http://lisp.rocks/posts-output/2018-02-13-〈微軟測試之道〉閱讀筆記/";
            this.page.identifier = "〈微軟測試之道〉閱讀筆記";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//fatfingererr.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    
</div>

                </div>
            </div>
            <div>
            </div>
        </div>
        <footer>Copyright &copy;  fatfingererr
            <p style="text-align: center;">Powered by <a href="http://cryogenweb.org">Cryogen</a> / Design by <a href="http://lambdafunk.com">Lambda Funk</a></p>
        </footer>
    </div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
</body>

</html>